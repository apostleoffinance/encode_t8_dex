/**
 * NOTE: This test script was generated by an AI assistant.
 * While it covers basic functionality, it should be thoroughly reviewed,
 * expanded, and customized to ensure comprehensive testing of the program.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { EncodeT8Dex } from "../target/types/encode_t8_dex";
import {
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID,
    createMint,
    createAssociatedTokenAccount,
    mintTo,
    getAccount,
    getAssociatedTokenAddress,
} from "@solana/spl-token";
import { assert } from "chai";

describe("encode_t8_dex", () => {
    // Configure the client to use the local cluster.
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.EncodeT8Dex as Program<EncodeT8Dex>;
    const payer = provider.wallet as anchor.Wallet;

    // Keypairs for the two tokens in the pool.
    const mintA_KP = anchor.web3.Keypair.generate();
    const mintB_KP = anchor.web3.Keypair.generate();
    const mintA = mintA_KP.publicKey;
    const mintB = mintB_KP.publicKey;

    // Variables to store addresses, accessible across tests.
    let userTokenAccountA: anchor.web3.PublicKey;
    let userTokenAccountB: anchor.web3.PublicKey;
    let poolPda: anchor.web3.PublicKey;

    // --- 1. TEST `initialize_pool` ---
    it("Initializes a new liquidity pool", async () => {
        // Create the mint accounts for the two tokens.
        await createMint(provider.connection, payer.payer, payer.publicKey, null, 6, mintA_KP);
        await createMint(provider.connection, payer.payer, payer.publicKey, null, 6, mintB_KP);

        [poolPda] = anchor.web3.PublicKey.findProgramAddressSync(
            [Buffer.from("pool"), mintA.toBuffer(), mintB.toBuffer()],
            program.programId
        );
        const [lpMintPda] = anchor.web3.PublicKey.findProgramAddressSync(
            [Buffer.from("lp_mint"), mintA.toBuffer(), mintB.toBuffer()],
            program.programId
        );

        const tokenVaultA_KP = anchor.web3.Keypair.generate();
        const tokenVaultB_KP = anchor.web3.Keypair.generate();

        await program.methods
            .initializePool()
            .accounts({
                pool: poolPda,
                mintA: mintA,
                mintB: mintB,
                lpMint: lpMintPda,
                tokenVaultA: tokenVaultA_KP.publicKey,
                tokenVaultB: tokenVaultB_KP.publicKey,
                payer: payer.publicKey,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: anchor.web3.SystemProgram.programId,
            })
            .signers([tokenVaultA_KP, tokenVaultB_KP])
            .rpc();

        const poolAccount = await program.account.pool.fetch(poolPda);
        assert.ok(poolAccount, "Pool account should exist after initialization.");
    });

    // --- 2. TEST `add_liquidity` (First Depositor) ---
    it("Adds the initial liquidity to the pool", async () => {
        // Setup user token accounts and mint tokens
        userTokenAccountA = await createAssociatedTokenAccount(provider.connection, payer.payer, mintA, payer.publicKey);
        userTokenAccountB = await createAssociatedTokenAccount(provider.connection, payer.payer, mintB, payer.publicKey);

        await mintTo(provider.connection, payer.payer, mintA, userTokenAccountA, payer.payer, 200_000_000); // 200 Token A
        await mintTo(provider.connection, payer.payer, mintB, userTokenAccountB, payer.payer, 200_000_000); // 200 Token B

        const amountA = new anchor.BN(100_000_000); // Deposit 100 tokens A
        const amountB = new anchor.BN(100_000_000); // Deposit 100 tokens B

        const poolAccount = await program.account.pool.fetch(poolPda);
        const userLpTokenAccount = await getAssociatedTokenAddress(poolAccount.lpMint, payer.publicKey);

        // Action
        await program.methods.addLiquidity(amountA, amountB).accounts({
            pool: poolPda,
            mintA: poolAccount.mintA,
            mintB: poolAccount.mintB,
            tokenVaultA: poolAccount.tokenVaultA,
            tokenVaultB: poolAccount.tokenVaultB,
            lpMint: poolAccount.lpMint,
            user: payer.publicKey,
            userTokenAccountA: userTokenAccountA,
            userTokenAccountB: userTokenAccountB,
            userLpTokenAccount: userLpTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        }).rpc();

        // Assertions
        const userLp_after = await getAccount(provider.connection, userLpTokenAccount);
        const expectedLpAmount = new anchor.BN(100_000_000); // Expected LP tokens = sqrt(100e6 * 100e6) = 100e6
        assert.ok(new anchor.BN(userLp_after.amount).eq(expectedLpAmount), `LP amount should be ${expectedLpAmount}`);
    });

    // --- 3. TEST `add_liquidity` (Second Depositor) ---
    it("Adds more liquidity, respecting the pool ratio", async () => {
        // Setup: Pool now has 100 A and 100 B (1:1 ratio). We deposit 50 A and 50 B.
        const amountA = new anchor.BN(50_000_000);
        const amountB = new anchor.BN(50_000_000);

        const poolAccount = await program.account.pool.fetch(poolPda);
        const userLpTokenAccount = await getAssociatedTokenAddress(poolAccount.lpMint, payer.publicKey);

        // Action
        await program.methods.addLiquidity(amountA, amountB).accounts({
            pool: poolPda,
            mintA: poolAccount.mintA,
            mintB: poolAccount.mintB,
            tokenVaultA: poolAccount.tokenVaultA,
            tokenVaultB: poolAccount.tokenVaultB,
            lpMint: poolAccount.lpMint,
            user: payer.publicKey,
            userTokenAccountA: userTokenAccountA,
            userTokenAccountB: userTokenAccountB,
            userLpTokenAccount: userLpTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        }).rpc();

        // Assertions
        const vaultA_after = await getAccount(provider.connection, poolAccount.tokenVaultA);
        const vaultB_after = await getAccount(provider.connection, poolAccount.tokenVaultB);
        assert.equal(Number(vaultA_after.amount), 150_000_000, "Vault A should have 150 tokens");
        assert.equal(Number(vaultB_after.amount), 150_000_000, "Vault B should have 150 tokens");

        const userLp_after = await getAccount(provider.connection, userLpTokenAccount);
        const expectedLpTotal = new anchor.BN(150_000_000); // 100 (first deposit) + 50 (second)
        assert.ok(new anchor.BN(userLp_after.amount).eq(expectedLpTotal), `Total LP should be ${expectedLpTotal}`);
    });

    // --- 4. TEST `swap` ---
    it("Swaps token A for token B", async () => {
        // Setup: Pool has 150 A and 150 B. User will swap 30 A.
        const amountIn = new anchor.BN(30_000_000);
        const minAmountOut = new anchor.BN(1); // We expect to receive at least 1 lamport.

        const poolAccount = await program.account.pool.fetch(poolPda);

        // Balances before the swap
        const userA_before = await getAccount(provider.connection, userTokenAccountA);
        const userB_before = await getAccount(provider.connection, userTokenAccountB);
        const vaultA_before = await getAccount(provider.connection, poolAccount.tokenVaultA);
        const vaultB_before = await getAccount(provider.connection, poolAccount.tokenVaultB);

        // Action
        await program.methods.swap(amountIn, minAmountOut).accounts({
            pool: poolPda,
            mintA: poolAccount.mintA,
            mintB: poolAccount.mintB,
            tokenVaultA: poolAccount.tokenVaultA,
            tokenVaultB: poolAccount.tokenVaultB,
            user: payer.publicKey,
            userTokenAccountIn: userTokenAccountA,
            userTokenAccountOut: userTokenAccountB,
            tokenProgram: TOKEN_PROGRAM_ID,
        }).rpc();

        // Balances after the swap
        const userA_after = await getAccount(provider.connection, userTokenAccountA);
        const userB_after = await getAccount(provider.connection, userTokenAccountB);
        const vaultA_after = await getAccount(provider.connection, poolAccount.tokenVaultA);
        const vaultB_after = await getAccount(provider.connection, poolAccount.tokenVaultB);

        // 1. User's token A balance should decrease by amountIn.
        assert.equal(
            Number(userA_before.amount) - Number(userA_after.amount),
            amountIn.toNumber(),
            "User A account balance change is incorrect"
        );

        // 2. Vault A balance should increase by amountIn.
        assert.equal(
            Number(vaultA_after.amount) - Number(vaultA_before.amount),
            amountIn.toNumber(),
            "Vault A balance change is incorrect"
        );

        // --- Calculate expected amount out ---
        // amount_in = 30_000_000, fee_rate = 1/1000
        // vault_in (A) = 150_000_000, vault_out (B) = 150_000_000
        // fee = 30_000_000 * 1 / 1000 = 30_000
        // amount_in_after_fee = 30_000_000 - 30_000 = 29_970_000
        // new_vault_out = (150e6 * 150e6) / (150e6 + 29.97e6) = 125_020_837
        // amount_out = 150_000_000 - 125_020_837 = 24_979_163
        const expectedAmountOut = 24979163;

        // 3. Vault B balance should decrease by the expected amount out.
        assert.equal(
            Number(vaultB_before.amount) - Number(vaultB_after.amount),
            expectedAmountOut,
            "Vault B balance change is incorrect"
        );

        // 4. User's token B balance should increase by the expected amount out.
        assert.equal(
            Number(userB_after.amount) - Number(userB_before.amount),
            expectedAmountOut,
            "User B account balance change is incorrect"
        );
    });
});
