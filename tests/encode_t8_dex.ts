/**
 * NOTE: This test script was generated by an AI assistant.
 * While it covers basic functionality, it should be thoroughly reviewed,
 * expanded, and customized to ensure comprehensive testing of the program.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { EncodeT8Dex } from "../target/types/encode_t8_dex";
import {
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID,
    createMint,
    createAssociatedTokenAccount,
    mintTo,
    getAccount,
    getAssociatedTokenAddress,
} from "@solana/spl-token";
import { assert } from "chai";

describe("encode_t8_dex", () => {
    // Configure the client to use the local cluster.
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.EncodeT8Dex as Program<EncodeT8Dex>;
    const payer = provider.wallet as anchor.Wallet;

    // Keypairs for the two tokens in the pool.
    const mintA_KP = anchor.web3.Keypair.generate();
    const mintB_KP = anchor.web3.Keypair.generate();
    const mintA = mintA_KP.publicKey;
    const mintB = mintB_KP.publicKey;

    // Variables to store addresses, accessible across tests.
    let userTokenAccountA: anchor.web3.PublicKey;
    let userTokenAccountB: anchor.web3.PublicKey;
    let poolPda: anchor.web3.PublicKey;
    let lpMintPda: anchor.web3.PublicKey;

    // --- 1. TEST `initialize_pool` ---
    it("Initializes a new liquidity pool", async () => {
        // Create the mint accounts for the two tokens.
        await createMint(provider.connection, payer.payer, payer.publicKey, null, 6, mintA_KP);
        await createMint(provider.connection, payer.payer, payer.publicKey, null, 6, mintB_KP);

        // Find the PDA addresses for the pool and its LP mint.
        [poolPda] = anchor.web3.PublicKey.findProgramAddressSync(
            [Buffer.from("pool"), mintA.toBuffer(), mintB.toBuffer()],
            program.programId
        );
        [lpMintPda] = anchor.web3.PublicKey.findProgramAddressSync(
            [Buffer.from("lp_mint"), mintA.toBuffer(), mintB.toBuffer()],
            program.programId
        );

        // Generate keypairs for the token vaults, as they are initialized in the instruction.
        const tokenVaultA_KP = anchor.web3.Keypair.generate();
        const tokenVaultB_KP = anchor.web3.Keypair.generate();

        // Invoke the `initializePool` instruction.
        await program.methods
            .initializePool()
            .accounts({
                pool: poolPda,
                mintA: mintA,
                mintB: mintB,
                lpMint: lpMintPda,
                tokenVaultA: tokenVaultA_KP.publicKey,
                tokenVaultB: tokenVaultB_KP.publicKey,
                payer: payer.publicKey,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: anchor.web3.SystemProgram.programId,
            })
            .signers([tokenVaultA_KP, tokenVaultB_KP])
            .rpc();

        // Assert that the pool account was created.
        const poolAccount = await program.account.pool.fetch(poolPda);
        assert.ok(poolAccount, "Pool account should exist after initialization.");
    });

    // --- 2. TEST `add_liquidity` ---
    it("Adds liquidity to the pool", async () => {
        // --- Setup ---
        // Create and fund the user's token accounts.
        userTokenAccountA = await createAssociatedTokenAccount(provider.connection, payer.payer, mintA, payer.publicKey);
        userTokenAccountB = await createAssociatedTokenAccount(provider.connection, payer.payer, mintB, payer.publicKey);

        await mintTo(provider.connection, payer.payer, mintA, userTokenAccountA, payer.payer, 1_000_000_000); // 1000 Token A
        await mintTo(provider.connection, payer.payer, mintB, userTokenAccountB, payer.payer, 1_000_000_000); // 1000 Token B

        const amountA = new anchor.BN(100_000_000); // 100 tokens A
        const amountB = new anchor.BN(200_000_000); // 200 tokens B

        // Fetch the pool state created in the previous test.
        const poolAccount = await program.account.pool.fetch(poolPda);

        // Find the user's associated token account address for the LP token.
        const userLpTokenAccount = await getAssociatedTokenAddress(poolAccount.lpMint, payer.publicKey);

        const userA_before = await getAccount(provider.connection, userTokenAccountA);

        // --- Action ---
        // Invoke the `addLiquidity` instruction.
        await program.methods.addLiquidity(amountA, amountB).accounts({
            pool: poolPda,
            mintA: poolAccount.mintA,
            mintB: poolAccount.mintB,
            tokenVaultA: poolAccount.tokenVaultA,
            tokenVaultB: poolAccount.tokenVaultB,
            lpMint: poolAccount.lpMint,
            user: payer.publicKey,
            userTokenAccountA: userTokenAccountA,
            userTokenAccountB: userTokenAccountB,
            userLpTokenAccount: userLpTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        }).rpc();

        // --- Assertions ---
        const vaultA_after = await getAccount(provider.connection, poolAccount.tokenVaultA);
        const vaultB_after = await getAccount(provider.connection, poolAccount.tokenVaultB);
        const userA_after = await getAccount(provider.connection, userTokenAccountA);
        const userLp_after = await getAccount(provider.connection, userLpTokenAccount);

        // 1. Vault balances should increase by the deposited amounts.
        assert.equal(Number(vaultA_after.amount), amountA.toNumber(), "Vault A balance is incorrect");
        assert.equal(Number(vaultB_after.amount), amountB.toNumber(), "Vault B balance is incorrect");
        // 2. User's token A balance should decrease.
        assert.equal(Number(userA_before.amount) - Number(userA_after.amount), amountA.toNumber(), "User A balance change is incorrect");
        // 3. User should receive LP tokens (current logic: amount = amount_a).
        assert.equal(Number(userLp_after.amount), amountA.toNumber(), "User LP token balance is incorrect");

        console.log("Liquidity added successfully!");
    });
});
